<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pong with TensorFlow.js AI</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.11.0/dist/tf.min.js"></script>
    <style>
        body {
            background: #1a1a2e;
            color: #fff;
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }
        #game {
            display: flex;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        canvas {
            border: 2px solid #16213e;
            border-radius: 8px;
        }
        #ai-info {
            width: 400px;
            height: 600px;
            background: #16213e;
            border-radius: 8px;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }
        #controls, #info, #score {
            margin-top: 10px;
            text-align: center;
        }
        button {
            background: #0f3460;
            border: none;
            color: #fff;
            padding: 10px 20px;
            text-align: center;
            font-size: 14px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 5px;
            transition: background 0.3s;
        }
        button:hover {
            background: #e94560;
        }
        #network-vis {
            width: 100%;
            height: calc(100% - 150px);
            background: #0f3460;
            border-radius: 5px;
            margin-top: 10px;
        }
        #stats {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            margin-top: 10px;
        }
        .ai-info {
            width: 48%;
            margin-bottom: 10px;
            font-size: 14px;
        }
        .bar {
            height: 5px;
            background: #e94560;
            margin-top: 2px;
            transition: width 0.3s ease-in-out;
        }
        h3 {
            margin-top: 0;
            text-align: center;
        }
        #made-by {
            position: absolute;
            bottom: 10px;
            right: 10px;
            font-size: 12px;
            color: #e94560;
        }
    </style>
</head>
<body>
    <div id="game">
        <div>
            <canvas id="pong" width="800" height="600"></canvas>
            <div id="score">Player: <span id="player-score">0</span> | AI: <span id="ai-score">0</span></div>
            <div id="info">Ball Speed: <span id="ball-speed">0</span></div>
            <div id="controls">
                <button id="start">Start</button>
                <button id="pause">Pause</button>
                <button id="reset">Reset</button>
            </div>
        </div>
        <div id="ai-info">
            <h3>AI Neural Network Visualization</h3>
            <canvas id="network-vis" width="400" height="450"></canvas>
            <div id="stats"></div>
        </div>
    </div>
    <div id="made-by">Made with &lt;3 by Your AI Assistant</div>

    <script>
        const canvas = document.getElementById("pong");
        const ctx = canvas.getContext("2d");
        const paddleHeight = 100;
        const paddleWidth = 10;
        const ballRadius = 5;
        const paddleSpeed = 5;
        const maxBallSpeed = 15;

        let playerY, aiY, ballX, ballY, ballSpeedX, ballSpeedY;
        let playerScore = 0, aiScore = 0;
        let isPlaying = false;
        let animationId = null;
        let aiPrediction = 0;
        let aiConfidence = 0;
        let networkLoss = 0;

        const drawRect = (x, y, w, h) => ctx.fillRect(x, y, w, h);
        const drawCircle = (x, y, r) => {
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.fill();
        };

        // Create the model
        const model = tf.sequential();
        model.add(tf.layers.dense({ units: 16, activation: 'relu', inputShape: [3] }));
        model.add(tf.layers.dense({ units: 8, activation: 'relu' }));
        model.add(tf.layers.dense({ units: 1, activation: 'tanh' }));
        model.compile({ optimizer: 'adam', loss: 'meanSquaredError' });

        // Initialize the model with some knowledge of Pong
        const initializeModel = async () => {
            const initialData = [
                { input: [0.5, 0.5, 0], output: [0] },  // Ball in center, no movement
                { input: [0.5, 0.25, -0.5], output: [-0.5] },  // Ball moving up, paddle should move up
                { input: [0.5, 0.75, 0.5], output: [0.5] },  // Ball moving down, paddle should move down
                { input: [0.25, 0.5, 0.5], output: [0] },  // Ball moving towards paddle, stay centered
            ];

            const xs = tf.tensor2d(initialData.map(d => d.input));
            const ys = tf.tensor2d(initialData.map(d => d.output));

            await model.fit(xs, ys, { epochs: 100, verbose: 0 });

            xs.dispose();
            ys.dispose();
        };

        initializeModel();

        const predictAiMove = async () => {
            const input = tf.tensor2d([[ballX / canvas.width, ballY / canvas.height, ballSpeedY / maxBallSpeed]]);
            const prediction = await model.predict(input).data();
            aiPrediction = prediction[0];
            aiY += aiPrediction * paddleSpeed;
            aiY = Math.max(0, Math.min(canvas.height - paddleHeight, aiY));
            aiConfidence = Math.abs(aiPrediction);
            input.dispose();
            updateStats();
            drawNetwork();
        };

        const trainModel = async () => {
            const input = tf.tensor2d([[ballX / canvas.width, ballY / canvas.height, ballSpeedY / maxBallSpeed]]);
            const label = tf.tensor2d([[(ballY - (aiY + paddleHeight / 2)) / (canvas.height / 2)]]);
            
            const result = await model.fit(input, label, { epochs: 1 });
            networkLoss = result.history.loss[0];

            input.dispose();
            label.dispose();
            updateStats();
            drawNetwork();
        };

        const update = async () => {
            if (isPlaying) {
                ballX += ballSpeedX;
                ballY += ballSpeedY;

                if (ballY < 0 || ballY > canvas.height) {
                    ballSpeedY = -ballSpeedY;
                }

                if (ballX < paddleWidth && ballY > playerY && ballY < playerY + paddleHeight) {
                    ballSpeedX = -ballSpeedX;
                    const deltaY = ballY - (playerY + paddleHeight / 2);
                    ballSpeedY += deltaY * 0.2;
                } else if (ballX < 0) {
                    aiScore++;
                    resetBall();
                }

                if (ballX > canvas.width - paddleWidth && ballY > aiY && ballY < aiY + paddleHeight) {
                    ballSpeedX = -ballSpeedX;
                    const deltaY = ballY - (aiY + paddleHeight / 2);
                    ballSpeedY += deltaY * 0.2;
                } else if (ballX > canvas.width) {
                    playerScore++;
                    resetBall();
                }

                await predictAiMove();
                await trainModel();

                updateBallSpeed();
                updateScore();
                draw();
            }

            animationId = requestAnimationFrame(update);
        };

        const resetBall = () => {
            ballX = canvas.width / 2;
            ballY = canvas.height / 2;
            ballSpeedX = 5 * (Math.random() > 0.5 ? 1 : -1);
            ballSpeedY = 5 * (Math.random() > 0.5 ? 1 : -1);
        };

        const updateScore = () => {
            document.getElementById("player-score").textContent = playerScore;
            document.getElementById("ai-score").textContent = aiScore;
        };

        const draw = () => {
            ctx.fillStyle = "#1a1a2e";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "#e94560";
            drawRect(0, playerY, paddleWidth, paddleHeight);
            drawRect(canvas.width - paddleWidth, aiY, paddleWidth, paddleHeight);
            drawCircle(ballX, ballY, ballRadius);

            if (!isPlaying) {
                ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
                ctx.font = "30px Arial";
                ctx.fillText("Paused", canvas.width / 2 - 50, canvas.height / 2);
            }
        };

        const startGame = () => {
            isPlaying = true;
            update();
        };

        const updateBallSpeed = () => {
            let speed = Math.sqrt(ballSpeedX * ballSpeedX + ballSpeedY * ballSpeedY);
            document.getElementById("ball-speed").textContent = speed.toFixed(2);
        };

        const initGame = () => {
            playerY = aiY = (canvas.height - paddleHeight) / 2;
            resetBall();
            updateScore();
            draw();
            updateBallSpeed();
            updateStats();
            drawNetwork();
        };

        const drawNetwork = () => {
            const networkCanvas = document.getElementById("network-vis");
            const netCtx = networkCanvas.getContext("2d");
            networkCanvas.width = 400;
            networkCanvas.height = 450;

            netCtx.clearRect(0, 0, networkCanvas.width, networkCanvas.height);

            const layers = [3, 16, 8, 1];
            const layerPositions = [50, 150, 250, 350];
            const inputLabels = ["Ball X", "Ball Y", "Ball Speed Y"];
            const colors = ["#ffd700", "#87cefa", "#90ee90", "#ff6347"];

            for (let i = 0; i < layers.length; i++) {
                for (let j = 0; j < layers[i]; j++) {
                    const x = layerPositions[i];
                    const y = (networkCanvas.height / (layers[i] + 1)) * (j + 1);
                    
                    if (i < layers.length - 1) {
                        for (let k = 0; k < layers[i + 1]; k++) {
                            const endX = layerPositions[i + 1];
                            const endY = (networkCanvas.height / (layers[i + 1] + 1)) * (k + 1);
                            netCtx.strokeStyle = `rgba(255, 255, 255, 0.1)`;
                            netCtx.lineWidth = 1;
                            netCtx.beginPath();
                            netCtx.moveTo(x, y);
                            netCtx.lineTo(endX, endY);
                            netCtx.stroke();
                        }
                    }

                    netCtx.fillStyle = colors[i];
                    netCtx.beginPath();
                    netCtx.arc(x, y, 5, 0, Math.PI * 2);
                    netCtx.fill();
                }
            }

            netCtx.fillStyle = "#fff";
            netCtx.font = "12px Arial";
            netCtx.textAlign = "right";
            for (let i = 0; i < inputLabels.length; i++) {
                const x = layerPositions[0] - 10;
                const y = (networkCanvas.height / (layers[0] + 1)) * (i + 1);
                netCtx.fillText(inputLabels[i], x, y + 3);
            }

            netCtx.textAlign = "left";
            netCtx.fillText("Movement", layerPositions[3] + 10, networkCanvas.height / 2);
        };

        const updateStats = () => {
            const statsDiv = document.getElementById("stats");
            const stats = [
                ["Prediction", aiPrediction.toFixed(2), -1, 1],
                ["Confidence", aiConfidence.toFixed(2), 0, 1],
                ["Network Loss", networkLoss ? networkLoss.toFixed(4) : "N/A", 0, 1],
            ];

            statsDiv.innerHTML = stats.map(stat => `
                <div class="ai-info">
                    <span>${stat[0]}: ${stat[1]}</span>
                    <div class="bar" style="width: ${100 * Math.min(Math.max((parseFloat(stat[1]) - stat[2]) / (stat[3] - stat[2]), 0), 1)}%"></div>
                </div>
            `).join("");
        };

        canvas.addEventListener("mousemove", (e) => {
            const rect = canvas.getBoundingClientRect();
            playerY = e.clientY - rect.top - paddleHeight / 2;
            playerY = Math.max(0, Math.min(canvas.height - paddleHeight, playerY));
        });

        document.getElementById("start").addEventListener("click", startGame);
        document.getElementById("pause").addEventListener("click", () => {
            isPlaying = false;
            cancelAnimationFrame(animationId);
            draw();
        });
        document.getElementById("reset").addEventListener("click", () => {
            cancelAnimationFrame(animationId);
            playerScore = aiScore = 0;
            initGame();
        });

        initGame();
    </script>
</body>
</html>
